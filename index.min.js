function attachStore(t,i){i._store=t,t.bindStores([...i.bindStores||[]],i),t._init({bindData:i.bindData||{}},i),Object.assign(i,t.mapActions(i.mapActions),t.mapMutations(i.mapMutations))}export class WxStore{constructor(t={}){this.__instance=[],this.__data=this._clone(t.data)||{},this.__mutations=t.mutations||{},this.__actions=t.actions||{},this.__dataMap={},this.__dataMirror={timer:null,data:null}}_clone(t){let i;if(t instanceof Array){i=[];let a=t.length;for(;a--;)i[a]=this._clone(t[a]);return i}if(t instanceof Object){i={};for(let a in t)i[a]=this._clone(t[a]);return i}return t}_fromatObjPath(t){let i=`${t[0]}`,a=t.slice(1);return a.length&&a.forEach(t=>{isNaN(t)?i+=`.${t}`:i+=`[${t}]`}),i}_assignObj(t,i,a){for(var e=0;e<i.length-1;e++)t[i[e]]instanceof Array&&isNaN(i[e+1])?t[i[e]]={}:t[i[e]]instanceof Object||(t[i[e]]=isNaN(i[e+1])?{}:[]),t=t[i[e]];t[i[e]]=a}_diff(t={},i={},a=[],e={}){for(let s in i){const n=a.concat([s]);i[s]instanceof Object&&t[s]instanceof Object?this._diff(t[s],i[s],n,e):i[s]!==t[s]&&(e[this._fromatObjPath(n)]=i[s])}return e}_map(t,i){let a=null;if(t instanceof Object){a={};for(let e in t)if("string"==typeof t[e]&&isNaN(t[e])){const s="string"==typeof e&&isNaN(e)?e:t[e],n=i&&i(t[e],s);void 0!==n&&(a[s]=n)}else t[e]instanceof Object&&Object.assign(a,this._map(t[e],i))}return a}_mapData(t,i){let a={};const e=this._map(t,(t,i)=>{if(a[t]=i,void 0!==this.__data[t])return this.__data[t];console.error(new Error(`data[${t} is undefined]`),this)});return i&&i(e,a),e}_getDataMap(t){const i=`wx_${t.__wxExparserNodeId__}`;return this.__dataMap[i]=this.__dataMap[i]||{},this.__dataMap[i]}_removeDataMap(t){const i=`wx_${t.__wxExparserNodeId__}`;delete this.__dataMap[i]}_update(t){t.__timer&&clearTimeout(t.__timer),t.__timer=setTimeout(()=>{t.setData(t.__diffData),t.__diffData={},t.__timer=null})}_init(t,i){i.__diffData=i.__diffData||{};let a=this._getDataMap(i);"object"==typeof t.bindData?this._mapData(t.bindData,(t,e)=>{Object.assign(a,e),!this.__instance.includes(i)&&this.__instance.push(i),t&&(Object.assign(i.__diffData,t),this._update(i))}):"function"==typeof t.bindData?(t.bindData=t.bindData(),this._init(t,i)):console.error(new Error("bindData is not object"),this)}_detach(t){let i=this.__instance.indexOf(t);i>-1&&this.__instance.splice(i,1),this._removeDataMap(t)}_dataMirror(){return this.__dataMirror.timer&&clearTimeout(this.__dataMirror.timer),this.__dataMirror.timer=setTimeout(()=>{this.__dataMirror.data=this.__dataMirror.timer=null}),this.__dataMirror.data||this._clone(this.__data)}bindStores(t,i){if(t instanceof Array){if(t[0]instanceof Object){const a=t.shift(),e=a[0]||a.store,s=a[1]||a.bindData;e&&e._init&&e._init({bindData:s},i),this.bindStores(t,i)}}else console.error(new Error("bindStores is not Array"),this)}setData(t){t instanceof Object?this.__instance.forEach((i,a)=>{let e=!1,s={},n=this._getDataMap(i);for(let o in t)if(void 0!==this.__data[o])void 0!==n[o]&&(e=!0,s[n[o]]=t[o]),!a&&(this.__data[o]=t[o]);else{let s=o.match(/[^\[|\]|\.]+/g);void 0!==this.__data[s[0]]&&s.length>1&&(void 0!==n[s[0]]&&(e=!0,i.__diffData[this._fromatObjPath([...s])]=t[o]),!a&&this._assignObj(this.__data,s,t[o]))}Object.assign(i.__diffData,this._diff(i.data,s)),e&&this._update(i)}):console.error(new Error("setData params should object"),this)}commit(t,i){"string"==typeof t&&"function"==typeof this.__mutations[t]?this.__mutations[t]({data:this._dataMirror(),payload:i,setData:this.setData.bind(this)}):console.error(new Error(`mutations["${t}"] is undefined`),this)}dispatch(t,i){"string"==typeof t&&"function"==typeof this.__actions[t]?this.__actions[t]({data:this._dataMirror(),payload:i,commit:this.commit.bind(this)}):console.error(new Error(`actions["${t}"] is undefined`),this)}mapMutations(t){return this._map(t,t=>{if("function"==typeof this.__mutations[t])return i=>{this.commit(t,i)};console.error(new Error(`mutations[${t}] is undefined`),this)})}mapActions(t){return this._map(t,t=>{if("function"==typeof this.__actions[t])return i=>{this.dispatch(t,i)};console.error(new Error(`actions[${t}] is undefined`),this)})}}export function getCurrentPage(t){const i=t.getPageId(),a=getCurrentPages();for(let t=0;t<a.length;t++)if(i===a[t].getPageId())return a[t]}export function StorePage(t){const i=t.onLoad,a=t.onUnload;t.onLoad=function(){attachStore(new WxStore(t.store),this),this.queueComponents.forEach(t=>{attachStore(this._store,t)}),delete this.queueComponents,i&&i.apply(this,arguments)},t.onUnload=function(){this._store&&this._store._detach(this),a&&a.apply(this,arguments)},Page(t)}export function StoreComponent(t){const i=t.attached,a=t.detached;t.attached=function(){const{bindData:a,bindStores:e,mapActions:s,mapMutations:n}=t;Object.assign(this,{bindData:a,bindStores:e,mapActions:s,mapMutations:n});const o=getCurrentPage(this);o._store?(attachStore(o._store,this),i&&i.apply(this,arguments)):(o.queueComponents=o.queueComponents||[],o.queueComponents.push(this),i&&i.apply(this,arguments))},t.detached=function(){this._store&&this._store._detach(this),a&&a.apply(this,arguments)},Component(t)}