function attachStore(t,a){a._store=t,t.bindStores([...a.bindStores||[]],a),t._init({bindData:a.bindData||{}},a),Object.assign(a,t.mapActions(a.mapActions),t.mapMutations(a.mapMutations))}function fromatObjPath(t){let a=`${t[0]}`,i=t.slice(1);return i.length&&i.forEach(t=>{isNaN(t)?a+=`.${t}`:a+=`[${t}]`}),a}export class WxStore{constructor(t={}){this.__instance=[],this.__data=clone(t.data)||{},this.__mutations=t.mutations||{},this.__actions=t.actions||{},this.__dataMap={},this.__dataMirror={timer:null,data:null}}_assignObj(t,a,i){for(var e=0;e<a.length-1;e++)t[a[e]]instanceof Array&&isNaN(a[e+1])?t[a[e]]={}:t[a[e]]instanceof Object||(t[a[e]]=isNaN(a[e+1])?{}:[]),t=t[a[e]];t[a[e]]=i}_map(t,a){let i=null;if(t instanceof Object){i={};for(let e in t)if("string"==typeof t[e]&&isNaN(t[e])){const n="string"==typeof e&&isNaN(e)?e:t[e],s=a&&a(t[e],n);void 0!==s&&(i[n]=s)}else t[e]instanceof Object&&Object.assign(i,this._map(t[e],a))}return i}_mapData(t,a){let i={};const e=this._map(t,(t,a)=>{if(i[t]=a,void 0!==this.__data[t])return this.__data[t];console.error(new Error(`data[${t} is undefined]`),this)});return a&&a(e,i),e}_getDataMap(t){const a=`wx_${t.__wxExparserNodeId__}`;return this.__dataMap[a]=this.__dataMap[a]||{},this.__dataMap[a]}_removeDataMap(t){const a=`wx_${t.__wxExparserNodeId__}`;delete this.__dataMap[a]}_update(t){t.__timer&&clearTimeout(t.__timer),t.__timer=setTimeout(()=>{t.setData(t.__diffData),t.__diffData={},t.__timer=null})}_init(t,a){a.__diffData=a.__diffData||{};let i=this._getDataMap(a);"object"==typeof t.bindData?this._mapData(t.bindData,(t,e)=>{Object.assign(i,e),!this.__instance.includes(a)&&this.__instance.push(a),t&&(Object.assign(a.__diffData,t),this._update(a))}):"function"==typeof t.bindData?(t.bindData=t.bindData(),this._init(t,a)):console.error(new Error("bindData is not object"),this)}_detach(t){let a=this.__instance.indexOf(t);a>-1&&this.__instance.splice(a,1),this._removeDataMap(t)}_dataMirror(){return this.__dataMirror.timer&&clearTimeout(this.__dataMirror.timer),this.__dataMirror.timer=setTimeout(()=>{this.__dataMirror.data=this.__dataMirror.timer=null}),this.__dataMirror.data||clone(this.__data)}bindStores(t,a){if(t instanceof Array){if(t[0]instanceof Object){const i=t.shift(),e=i[0]||i.store,n=i[1]||i.bindData;e&&e._init&&e._init({bindData:n},a),this.bindStores(t,a)}}else console.error(new Error("bindStores is not Array"),this)}setData(t){"[object Object]"===Object.prototype.toString.call(t)?this.__instance.forEach((a,i)=>{let e=!1,n={},s=this._getDataMap(a);for(let o in t)if(void 0!==this.__data[o])void 0!==s[o]&&(e=!0,n[s[o]]=t[o]),!i&&(this.__data[o]=t[o]);else{let n=o.match(/[^\[|\]|\.]+/g);void 0!==this.__data[n[0]]&&n.length>1&&(void 0!==s[n[0]]&&(e=!0,a.__diffData[fromatObjPath([...n])]=t[o]),!i&&this._assignObj(this.__data,n,t[o]))}Object.assign(a.__diffData,diff(a.data,n)),e&&this._update(a)}):console.error(new Error("setData params should object"),this)}commit(t,a){"string"==typeof t&&"function"==typeof this.__mutations[t]?this.__mutations[t]({data:this._dataMirror(),payload:a,setData:this.setData.bind(this)}):console.error(new Error(`mutations["${t}"] is undefined`),this)}dispatch(t,a){"string"==typeof t&&"function"==typeof this.__actions[t]?this.__actions[t]({data:this._dataMirror(),payload:a,commit:this.commit.bind(this)}):console.error(new Error(`actions["${t}"] is undefined`),this)}mapMutations(t){return this._map(t,t=>{if("function"==typeof this.__mutations[t])return a=>{this.commit(t,a)};console.error(new Error(`mutations[${t}] is undefined`),this)})}mapActions(t){return this._map(t,t=>{if("function"==typeof this.__actions[t])return a=>{this.dispatch(t,a)};console.error(new Error(`actions[${t}] is undefined`),this)})}}export function diff(t={},a={},i=[],e={}){for(let n in a){const s=i.concat([n]);a[n]instanceof Object&&t[n]instanceof Object?diff(t[n],a[n],s,e):a[n]!==t[n]&&(e[fromatObjPath(s)]=a[n])}return e}export function clone(t){let a;if(t instanceof Array){a=[];let i=t.length;for(;i--;)a[i]=clone(t[i]);return a}if(t instanceof Object){a={};for(let i in t)a[i]=clone(t[i]);return a}return t}export function getCurrentPage(t){const a=t.getPageId(),i=getCurrentPages();for(let t=0;t<i.length;t++)if(a===i[t].getPageId())return i[t]}export function StorePage(t){const a=t.onLoad,i=t.onUnload;t.onLoad=function(){attachStore(new WxStore(t.store),this),this.queueComponents.forEach(t=>{attachStore(this._store,t)}),delete this.queueComponents,a&&a.apply(this,arguments)},t.onUnload=function(){this._store&&this._store._detach(this),i&&i.apply(this,arguments)},Page(t)}export function StoreComponent(t){const a=t.attached,i=t.detached;t.attached=function(){const{bindData:i,bindStores:e,mapActions:n,mapMutations:s}=t;Object.assign(this,{bindData:i,bindStores:e,mapActions:n,mapMutations:s});const o=getCurrentPage(this);o._store?(attachStore(o._store,this),a&&a.apply(this,arguments)):(o.queueComponents=o.queueComponents||[],o.queueComponents.push(this),a&&a.apply(this,arguments))},t.detached=function(){this._store&&this._store._detach(this),i&&i.apply(this,arguments)},Component(t)}